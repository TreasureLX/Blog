### 从单例模式到Java反射、序列化、字节码

1. 应用场景

   


2. 饿汉式单例

   ```java
   package com.lx.learning.designpattern.singleton.hungry;
   
   public class HungrySingleton {
   
       private static final HungrySingleton instance=new HungrySingleton();
   
       private HungrySingleton() {
       }
   
       public static HungrySingleton getInstance(){
           return instance;
       }
   
   }
   ```

   缺点：不需要使用这个单例的话也会创建对象，占用空间

3. 懒汉式单例

    ```java
    package com.lx.learning.designpattern.singleton.lazy;
    
    public class LazySingleton {
    
        private static LazySingleton instance = null;
    
        private LazySingleton() { }
    
        public static synchronized LazySingleton getInstance() {
            if (instance == null) {
                instance = new LazySingleton();
            }
            return instance;
        }
    
    }
    ```

    双重检测锁机制

    ```java
    package com.lx.learning.designpattern.singleton.lazy;
    
    public class LazySingleton {
    
        private static LazySingleton instance = null;
    
        private LazySingleton() {
        }
    
        public static LazySingleton getInstance() {
            if (instance == null) {
                synchronized (LazySingleton.class) {
                    if (instance == null) {
                        instance = new LazySingleton();
                    }
                }
            }
            return instance;
        }
    }
    ```

    静态内部类的方式执行，静态内部类加载时机

    没有用到内部类的时候，不会加载内部类

    用的时候会先加载内部类，并且类只会加载一次，这个时候也就把单例初始化了

    字节码看原理

4. 单例的破坏

   反射破坏单例的代码如下：懒汉式只能防止静态内部类的方式，饿汉式都能被防止

   ```java
   package com.lx.learning.designpattern.singleton.test;
   
   import com.lx.learning.designpattern.singleton.hungry.HungrySingleton;
   import java.lang.reflect.Constructor;
   
   public class ReflectSingleton {
   
       public static void main(String[] args) {
           Class<HungrySingleton> clazz = HungrySingleton.class;
           try {
               //1.获取单例的构造器
               Constructor<HungrySingleton> constructor = clazz.getDeclaredConstructor();
               //2.因为构造器为私有的，所以要设置成私有可以被反射访问
               constructor.setAccessible(true);
               //3.通过反射生成两个对象
               HungrySingleton singleton1 = constructor.newInstance();
               HungrySingleton singleton2 = constructor.newInstance();
               //4.输出这两个对象的HashCode
               System.out.println("Singleton1 hashCode==>" + singleton1.hashCode());
               System.out.println("Singleton2 hashCode==>" + singleton2.hashCode());
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   }
   ```

   运行结构如下，HashCode不同说明生成了两个不同的对象，单例模式就被破坏了

   ```
   Singleton1 hashCode==>1956725890
   Singleton2 hashCode==>356573597
   ```

   防止单例被反射破坏的解决方案，下面方案只适用于饿汉式和静态内部类的方式

    ```java
   package com.lx.learning.designpattern.singleton.hungry;
   
   public class HungrySingleton {
   
       private static final HungrySingleton instance = new HungrySingleton();
   
       private HungrySingleton() {
           if (instance != null){
               throw  new RuntimeException("单例已存在，不允许重新创建");
           }
       }
   
       public static HungrySingleton getInstance() {
           return instance;
       }
   
   }
    ```

   防止单例被反序列化破坏

   ```java
   package com.lx.learning.designpattern.singleton.serial;
   
   import com.lx.learning.designpattern.singleton.hungry.HungrySingleton;
   
   public class SingletonSerialTest {
       public static void main(String[] args) {
           HungrySingleton singleton = HungrySingleton.getInstance();
           byte[] bytes = SerialUtil.serial(singleton);
           HungrySingleton hungrySingleton1 = SerialUtil.deSerial(bytes);
           HungrySingleton hungrySingleton2 = SerialUtil.deSerial(bytes);
           System.out.println(hungrySingleton1 == hungrySingleton2);
       }
   }
   ```

   SerialUtil工具类代码如下：

   ```java
   package com.lx.learning.designpattern.singleton.serial;
   
   import java.io.ByteArrayInputStream;
   import java.io.ByteArrayOutputStream;
   import java.io.ObjectInputStream;
   import java.io.ObjectOutputStream;
   
   public class SerialUtil {
   
       public static <T> byte[] serial(T object) {
           try {
               ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
               ObjectOutputStream objectOutputStream=new ObjectOutputStream(byteArrayOutputStream);
               objectOutputStream.writeObject(object);
               return byteArrayOutputStream.toByteArray();
           } catch (Exception e) {
               e.printStackTrace();
           }
           return null;
       }
   
       public static <T>  T deSerial(byte[] data) {
           try {
               ByteArrayInputStream byteArrayInputStream=new ByteArrayInputStream(data);
               ObjectInputStream objectInputStream=new ObjectInputStream(byteArrayInputStream);
               return (T)objectInputStream.readObject();
           } catch (Exception e) {
               e.printStackTrace();
           }
           return null;
       }
   
   }
   
   ```

   运行结果为`false`，说明单例可以通过反序列化的手段来破坏。那么如果来防止通过序列化的手段来破坏单例呢。可以通过序列化中readResolve()方法来防止，只需要在该方法中调用获取单例的方法即可。java在反序列化时会先通过反射获取对象的readResolve，如果该方法不为空则通过该方法来生成对象，否则生成新的对象。防止序列化破坏单例的代码如下所示：

   ```java
   package com.lx.learning.designpattern.singleton.hungry;
   
   import java.io.Serializable;
   
   public class HungrySingleton implements Serializable {
   
       private static final HungrySingleton instance = new HungrySingleton();
   
       private HungrySingleton() {
           if (instance != null){
               throw  new RuntimeException("单例已存在，不允许重新创建");
           }
       }
   
       public static HungrySingleton getInstance() {
           return instance;
       }
   
       private Object readResolve(){
           return getInstance();
       }
   
   }
   ```

   

5. 枚举式单例

   通过枚举来实现饿汉（注册是单例），为什么反序列化之后枚举单例还是相等

    ```java
    package com.lx.learning.designpattern.singleton.enumeration;
   
    public enum EnumSingleton {
        INSTANCE;
        private String name;
   
        public void test() {
            System.out.println(name);
        }
   
        public void setName(String name) {
            this.name = name;
        }
    }
    ```

6. 容器式单例

   对象方便管理，线程安全问题

   ```java
   package com.lx.learning.designpattern.singleton.container;
   
   import java.util.Map;
   import java.util.concurrent.ConcurrentHashMap;
   
   public class ContainerSingleton {
   
       private static Map<String, Object> container = new ConcurrentHashMap<>();
   
       private ContainerSingleton() {
       }
   
       private static Object getInstance(String name) {
           //如果容器中包含要去的单例则直接返回不创建单例了，这里使用是双重检测机制
           if (!container.containsKey(name)) {
               synchronized (ContainerSingleton.class){
                   if (!container.containsKey(name)) {
                       try {
                           Class clazz = Class.forName(name);
                           Object obj = clazz.newInstance();
                           container.put(name, obj);
                           return obj;
                       } catch (Exception e) {
                           e.printStackTrace();
                       }
                   }
               }
           }
           return container.get(name);
       }
   
       public static void main(String[] args) {
           Object obj=getInstance("com.lx.learning.designpattern.singleton.container.User");
           System.out.println(obj);
       }
   }
   ```

7. ThreadLocalSingleton，保证线程内部的全局唯一，且天生线程安全

   ```java
   package com.lx.learning.designpattern.singleton.thread;
   
   public class ThreadLocalSingleton {
   
       private ThreadLocalSingleton(){
       }
   
       private static final ThreadLocal<ThreadLocalSingleton> instance=
               ThreadLocal.withInitial(ThreadLocalSingleton::new);
   
       public static ThreadLocalSingleton getInstance(){
           return instance.get();
       }
   }
   ```

   单例模式优点

   ```
   内存中只有一个实例，减少了内存开销
   可以避免对资源的多重使用
   设置全局访问点，严格控制访问
   ```

   缺点

   ```
   没有接口，扩展困难
   ```



