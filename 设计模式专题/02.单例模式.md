### 从单例模式到Java反射、序列化及字节码

1. 应用场景

   ​	单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。单例模式是创建型模式。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 


2. 饿汉式单例

   ​	饿汉式单例是在类加载的时候创建单例对象，不存在线程安全问题，获取单例效率高，体验更好。缺点是如果系统中没有用到这个单例，它会一直占用内存空间，浪费了内存空间。饿汉式单例模式代码如下所示：

   ```java
   package com.lx.learning.designpattern.singleton.hungry;
   
   public class HungrySingleton {
   	//在类加载的时候单例便创建了
       private static final HungrySingleton instance=new HungrySingleton();
   
       private HungrySingleton() {
       }
   
       public static HungrySingleton getInstance(){
           return instance;
       }
   
   }
   ```

3. 懒汉式单例

    ​	顾名思义，懒汉式单例就是在需要用到的时候再创建单例对象，这样便可以解决不使用单例也占空间的问题，代码如下所示。但是下面这个单例写法会产生线程安全问题，在`new LazySingleton()`的时候需要时间，单例在创建的过程中有可能`instance`为空，这个时候有别的线程来访问`getInstance()`的话也可以进入创建单例的代码块，这样“单例”就被多次创建，出现线程安全问题。

    ```java
    package com.lx.learning.designpattern.singleton.lazy;
    
    public class LazySingleton {
    
        private static LazySingleton instance = null;
    
        private LazySingleton() { }
    
        public static LazySingleton getInstance() {
            if (instance == null) {
                //有可能多个线程进入这个代码块
                instance = new LazySingleton();
            }
            return instance;
        }
    }
    ```

    ​	那么该怎么解决这个问题呢，最简单粗暴的方法是在`getInstance()`方法前加上`synchronized`关键字，使获取单例的方法只有一个线程能访问。但是这么做的话，会出现性能问题，在高并发的场景下会导致大量的线程阻塞，导致系统性能下降。双重检查锁机制便可以解决线程安全和性能问题，代码如下所示。第一个`if`判断语句的作用是单例已经创建好的情况下，线程不用在进入同步块了。第二个`if`判断语句的作用是单例还没创建的情况下保证只用一个线程能创建单例。这样便实现了需要时创建和线程安全的单例模式。

    ```java
    package com.lx.learning.designpattern.singleton.lazy;
    
    public class LazySingleton {
    
        private static LazySingleton instance = null;
    
        private LazySingleton() {
        }
    
        public static LazySingleton getInstance() {
            if (instance == null) {
                synchronized (LazySingleton.class) {
                    if (instance == null) {
                        instance = new LazySingleton();
                    }
                }
            }
            return instance;
        }
    }
    ```

    静态内部类的方式执行，静态内部类加载时机

    没有用到内部类的时候，不会加载内部类

    用的时候会先加载内部类，并且类只会加载一次，这个时候也就把单例初始化了

    字节码看原理

    ```java
    package com.lx.learning.designpattern.singleton.lazy;
    
    public class LazyInnerClassSingleton {
    
        private LazyInnerClassSingleton() {
        }
    
        public LazyInnerClassSingleton getInstance(){
            return LazyHolder.instance;
        }
    
        private static class LazyHolder{
            private static final LazyInnerClassSingleton instance=new LazyInnerClassSingleton();
        }
    }
    ```

4. 枚举式单例

   通过枚举来实现饿汉（注册是单例），为什么反序列化之后枚举单例还是相等

   ```java
    package com.lx.learning.designpattern.singleton.enumeration;
   
    public enum EnumSingleton {
        INSTANCE;
        private String name;
   
        public void test() {
            System.out.println(name);
        }
   
        public void setName(String name) {
            this.name = name;
        }
    }
   ```

5. 容器式单例

   对象方便管理，线程安全问题

   ```java
   package com.lx.learning.designpattern.singleton.container;
   
   import java.util.Map;
   import java.util.concurrent.ConcurrentHashMap;
   
   public class ContainerSingleton {
   
       private static Map<String, Object> container = new ConcurrentHashMap<>();
   
       private ContainerSingleton() {
       }
   
       private static Object getInstance(String name) {
           //如果容器中包含要去的单例则直接返回不创建单例了，这里使用是双重检测机制
           if (!container.containsKey(name)) {
               synchronized (ContainerSingleton.class){
                   if (!container.containsKey(name)) {
                       try {
                           Class clazz = Class.forName(name);
                           Object obj = clazz.newInstance();
                           container.put(name, obj);
                           return obj;
                       } catch (Exception e) {
                           e.printStackTrace();
                       }
                   }
               }
           }
           return container.get(name);
       }
   
       public static void main(String[] args) {
           Object obj=getInstance("com.lx.learning.designpattern.singleton.container.User");
           System.out.println(obj);
       }
   }
   ```

6. ThreadLocalSingleton，保证线程内部的全局唯一，且天生线程安全

   ```java
   package com.lx.learning.designpattern.singleton.thread;
   
   public class ThreadLocalSingleton {
   
       private ThreadLocalSingleton(){
       }
   
       private static final ThreadLocal<ThreadLocalSingleton> instance=
               ThreadLocal.withInitial(ThreadLocalSingleton::new);
   
       public static ThreadLocalSingleton getInstance(){
           return instance.get();
       }
   }
   ```

7. 单例的破坏

   反射破坏单例的代码如下：懒汉式只能防止静态内部类的方式，饿汉式都能被防止

   ```java
   package com.lx.learning.designpattern.singleton.test;
   
   import com.lx.learning.designpattern.singleton.hungry.HungrySingleton;
   import java.lang.reflect.Constructor;
   
   public class ReflectSingleton {
   
       public static void main(String[] args) {
           Class<HungrySingleton> clazz = HungrySingleton.class;
           try {
               //1.获取单例的构造器
               Constructor<HungrySingleton> constructor = clazz.getDeclaredConstructor();
               //2.因为构造器为私有的，所以要设置成私有可以被反射访问
               constructor.setAccessible(true);
               //3.通过反射生成两个对象
               HungrySingleton singleton1 = constructor.newInstance();
               HungrySingleton singleton2 = constructor.newInstance();
               //4.输出这两个对象的HashCode
               System.out.println("Singleton1 hashCode==>" + singleton1.hashCode());
               System.out.println("Singleton2 hashCode==>" + singleton2.hashCode());
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   }
   ```

   运行结构如下，HashCode不同说明生成了两个不同的对象，单例模式就被破坏了

   ```
   Singleton1 hashCode==>1956725890
   Singleton2 hashCode==>356573597
   ```

   防止单例被反射破坏的解决方案，下面方案只适用于饿汉式和静态内部类的方式

    ```java
   package com.lx.learning.designpattern.singleton.hungry;
   
   public class HungrySingleton {
   
       private static final HungrySingleton instance = new HungrySingleton();
   
       private HungrySingleton() {
           if (instance != null){
               throw  new RuntimeException("单例已存在，不允许重新创建");
           }
       }
   
       public static HungrySingleton getInstance() {
           return instance;
       }
   
   }
    ```

   防止单例被反序列化破坏

   ```java
   package com.lx.learning.designpattern.singleton.serial;
   
   import com.lx.learning.designpattern.singleton.hungry.HungrySingleton;
   
   public class SingletonSerialTest {
       public static void main(String[] args) {
           HungrySingleton singleton = HungrySingleton.getInstance();
           byte[] bytes = SerialUtil.serial(singleton);
           HungrySingleton hungrySingleton1 = SerialUtil.deSerial(bytes);
           HungrySingleton hungrySingleton2 = SerialUtil.deSerial(bytes);
           System.out.println(hungrySingleton1 == hungrySingleton2);
       }
   }
   ```

   SerialUtil工具类代码如下：

   ```java
   package com.lx.learning.designpattern.singleton.serial;
   
   import java.io.ByteArrayInputStream;
   import java.io.ByteArrayOutputStream;
   import java.io.ObjectInputStream;
   import java.io.ObjectOutputStream;
   
   public class SerialUtil {
   
       public static <T> byte[] serial(T object) {
           try {
               ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
               ObjectOutputStream objectOutputStream=new ObjectOutputStream(byteArrayOutputStream);
               objectOutputStream.writeObject(object);
               return byteArrayOutputStream.toByteArray();
           } catch (Exception e) {
               e.printStackTrace();
           }
           return null;
       }
   
       public static <T>  T deSerial(byte[] data) {
           try {
               ByteArrayInputStream byteArrayInputStream=new ByteArrayInputStream(data);
               ObjectInputStream objectInputStream=new ObjectInputStream(byteArrayInputStream);
               return (T)objectInputStream.readObject();
           } catch (Exception e) {
               e.printStackTrace();
           }
           return null;
       }
   
   }
   
   ```

   运行结果为`false`，说明单例可以通过反序列化的手段来破坏。那么如果来防止通过序列化的手段来破坏单例呢。可以通过序列化中readResolve()方法来防止，只需要在该方法中调用获取单例的方法即可。java在反序列化时会先通过反射获取对象的readResolve，如果该方法不为空则通过该方法来生成对象，否则生成新的对象。防止序列化破坏单例的代码如下所示：

   ```java
   package com.lx.learning.designpattern.singleton.hungry;
   
   import java.io.Serializable;
   
   public class HungrySingleton implements Serializable {
   
       private static final HungrySingleton instance = new HungrySingleton();
   
       private HungrySingleton() {
           if (instance != null){
               throw  new RuntimeException("单例已存在，不允许重新创建");
           }
       }
   
       public static HungrySingleton getInstance() {
           return instance;
       }
   
       private Object readResolve(){
           return getInstance();
       }
   
   }
   ```

8. 单例模式总结

   单例模式优点

   ```
   内存中只有一个实例，减少了内存开销
   可以避免对资源的多重使用
   设置全局访问点，严格控制访问
   ```

   缺点

   ```
   没有接口，扩展困难
   ```



