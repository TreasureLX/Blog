### 类的加载机制

1. 类的加载时机

   * 使用new关键字创建对象的时候
   * 读取或设置一个类的静态字段，调用类的静态方法
   * 通过反射实例化对象的时候

   * 初始化一个类时如果其父类没有初始化则先初始化其父类
   * 虚拟机启动时优先初始化包含main方法的主类

2. 接口初始化

   ```
   编译器会给接口生成"<clinit>()"类构造器，用于初始化类接口中所定义的成员变量
   一个接口在初始化的时候，并不要求其父类接口全部完成了初始化
   ```

3. 类加载器及其加载的内容

   | 类加载器               | 加载内容 |
   | :-------------: | :------: |
   | BootstrapClassLoader   | <JAVA_HOME>\lib目录中的或者被-Xbootclasspath参数所指定路径中的，并且是虚拟机识别的，如rt.jar |
   | ExtensionClassLoader   | <JAVA_HOME>\lib\ext目录中的或者被java.ext.dirs系统变量所指定的路径中 |
   | ApplicationClassLoader | 负责加载用户类路径上所指定的类库 |
   | 自定义类加载器         | 热部署 代码保护 加解密 |

4. 破坏双亲委派机制

   ```
   重写loadClass方法
   OSGI隔离
   ```

5. 类加载详细过程

* 加载

  ```
  通过一个类的全限定名来获取第一此类的二进制流
  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  在内存中生成一个表达这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口
  ```

* 验证

  ```
  文件格式验证
  元数据验证
  字节码验证
  符号引用验证
  ```

* 准备

  ```
   正式为类变量分配内存并设置初始值
   public static int value=10         value在准备阶段给value分配内存空间，并设置初始值默认值
   public static final int value=10   如果value是常量在准备阶段则分配空间并设置常量值为0
  ```

* 解析

  ```
  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程
  1.类或接口的解析
  2.字段解析
  3.类方法解析
  4.接口方法解析
  ```

* 初始化

  ```
  开始真正的执行java代码
  执行类构造器<clinit>
  1.<clinit>方式是有编译器收集类中的类变量赋值动作和静态语句块（static{}）中的语句合并产生的，编译器   收集的顺序是由语句在源文件中出现的顺序决定的。
      static {
          i=10;
          System.out.println(i);  //编译会提示非法向前引用错误
      }
      static int i = 10;
  2.<clinit>不用显式的调用父类的类构造方法，虚拟机会保证在子类的<clinit>方法执行之前，父类的<clinit>已经执行完毕。
  3.父类的静态代码块（static{}）先于子类的静态代码块执行
  4.如果没有静态代码块和静态变量则编译器不会生成<clinit>方法
  5.接口中不能有静态代码块，可以有静态变量，执行接口的<clinit>方法不用先执行其父类的<clinit>方法，除非使用到定义在父类接口的静态变量
  6.<clinit>方法是线程安全，只会执行一次
  ```

* 使用

  ```
  调用类的方法
  ```

* 卸载

  ```
  
  ```

  