### SpringBoot中的SpringApplication

1. `SpringBoot`的多种启动方式

   ```java
   //a.通过SpringApplicationBuilder来启动
   new SpringApplicationBuilder(MicroServiceApplication.class)
       .properties("server.port=0").run(args);
   //b.通过自定义SpringApplication来启动
   SpringApplication application=new 
       SpringApplication(MicroServiceApplication.class);
       Map<String,Object> properties=new LinkedHashMap<>();
       properties.put("server.port",0);
       application.setDefaultProperties(properties);
       application.run(args);
   ```

2. `@SpringBootApplication`注解详解

   ```java
   @Target(ElementType.TYPE)
   @Retention(RetentionPolicy.RUNTIME)
   @Documented
   @Inherited
   @SpringBootConfiguration
   @EnableAutoConfiguration
   @ComponentScan(excludeFilters = {
   		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
   		@Filter(type = FilterType.CUSTOM,
   				classes = AutoConfigurationExcludeFilter.class) })
   ```

   `@ComponentScan`是Spring3.1出现的

   `@EnableAutoConfiguration`激活自动装配->@Enable*

   * `EnableWebMvc`
   * `EnableAsync`
   * `EnableCaching`

   `@SpringBootConfiguration`->`@Configuration`相当于Configuration.class

3. 注解驱动上下文`AnnotationConfigApplicationContext`，SpringFramework3.0引入的。

   Spring注解编程模型 wiki -> [Spring Annotation Programming Model](<https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model>)

4. `@Componet`的派生性

   `@ComponentScan`扫描含有`@Component`注解的实体类

   处理类：`ConfigurationClassParser`

   扫描类：`ClassPathBeanDefinitionScanner`

   父类：`ClassPathScanningCandidateComponentProvider`

   ```java
   protected void registerDefaultFilters() {
       	//只扫描有@Component注解的类
   		this.includeFilters.add(new AnnotationTypeFilter(Component.class));
   		......
   	}
   ```

   * `@Service`

     ```java
     @Component
     public @interface Service {
     }
     ```

   * `@Controller`

     ```java
     @Component
     public @interface Controller {
     }
     ```

   * `@Repository`

     ```java
     @Component
     public @interface Repository {
     }
     ```

5. 自定义`SpringBoot`引导示例

   ```java
   @Configuration
   public class SpringAnnotationDemo {
       public static void main(String[] args) {
           //注解驱动
           //@Bean @Configuration
           AnnotationConfigApplicationContext applicationContext=new AnnotationConfigApplicationContext();
           applicationContext.register(SpringAnnotationDemo.class);
           applicationContext.refresh();
           System.out.println(applicationContext.getBean(SpringAnnotationDemo.class));
       }
   }
   
   ```

6. `SpringApplication`类型推断

   `SpringApplication()` -> `WebApplicationType.deduceFromClasspath()` -> 自定义WebApplicationType

   a. `WebApplicationType.NONE`

   * `Servlet`不存在
   * `ConfigurableWebApplicationContext`不存在

   b. `WebApplicationType.SERVLET`

   * `Servlet`存在
   * `ConfigurableWebApplicationContext`存在

   c. `WebApplicationType.REACTIVE`

   * 只有`DispatcherHandler`存在

   `SpringApplication` 是 `SpringBoot` 引导 `ApplicationContext` 初始化的启动类

7. `Spring`中的事件

   `ApplicationEvent`消息

   `ApplicationListener`消费者

   `ApplicationEventMulticaster`相当于消息发布者，实现类`SimpleApplicationEventMulticaster`

8. SpringBoot事件机制

   ```java
   @EnableAutoConfiguration
   public class SpringBootEventDemo {
       public static void main(String[] args) {
           new SpringApplicationBuilder(SpringBootEventDemo.class)
                   .listeners(event -> {
                       System.out.println("监听到事件："+event.getClass().getSimpleName());
                   })
                   .run(args)
                   .close();
       }
   }
   ```

   1. ApplicationStartingEvent

   2. ApplicationEnvironmentPreparedEvent

   3. ApplicationContextInitializedEvent

   4. ApplicationPreparedEvent

   5. ContextRefreshedEvent

   6. ServletWebServerInitializedEvent

   7. ApplicationStartedEvent

   8. ApplicationReadyEvent

   9. ContextClosedEvent
   10. ApplicationFailedEvent