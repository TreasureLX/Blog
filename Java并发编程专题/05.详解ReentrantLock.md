### ReentrantLock源码解析

ReentrantLock锁是基于JDK实现的，其思路跟synchronized关键字在JVM中实现的锁大同小异。下面我们来看看ReentrantLock是怎样实现的。

1. 首先来看`java.util.concurrent.locks.ReentrantLock#lock`方法，它是ReentrantLock的入口

   ```java
   public void lock() {
   		//调用了静态内部类java.util.concurrent.locks.ReentrantLock.Sync的lock方法
           sync.lock();
       }
   ```


2. Sync有两个子类，公平锁和非公平锁的实现，分别是`java.util.concurrent.locks.ReentrantLock.NonfairSync`，`java.util.concurrent.locks.ReentrantLock.FairSync`。先看看`NonfairSync`中的源码

   ```java
   final void lock() {
       //首先通过CAS操作来替换state属性，如果替换成功则获取锁，并设置互斥线程,这里类似于JVM中
       //synchronized的偏向锁
       if (compareAndSetState(0, 1))
           setExclusiveOwnerThread(Thread.currentThread());
       else
           //如果CAS不能获取到锁则进入下面的逻辑
           acquire(1);
   }
   
   ```

3. 